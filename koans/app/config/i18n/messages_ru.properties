beginner.AboutKoans.findAboutKoansFile=Вам нужно открыть файл ${file_path}${file_name}.java. Там должен быть метод перед ним есть аннотация @Koan и имя этого метода ${method_name}, в нем ваше первое задание. Поле того как вы решите это задание, сохраните файл с решением и возвращайтесь сюда за следующим заданием.
beginner.AboutKoans.definitionOfKoanCompletion=Коан считается завершенным, когда он больше не выдает исключение. Часто существует более одного способа решить коан, но только один из них правильный. Подсказа на правильный путь часто содержится в самом коане или появляется здесь.

beginner.AboutAssertions.assertBooleanTrue=__ (пропуск) указывает куда надо поместить ответ. Судя по контексту, чем надо заменить __?
beginner.AboutAssertions.assertBooleanFalse=Like the prior koan. Подумайте над тем, какой мощный иструмент простые assert при проверке поведения объекта.
beginner.AboutAssertions.assertNullObject=В java не инициализированная ссылка содержит в себе значиение которое обозначатеся ключевым словом null. Иногда необходимо, что бы что-то был null и этот assert может это проверить.
beginner.AboutAssertions.assertNotNullObject=Иногда вы хотите убедиться, что объект не null. Этот assert следует использовать с осторожностью и лучше использовть более точный assert.
beginner.AboutAssertions.assertEqualsUsingExpression=Вы можете использовать выражения внутри assert, что бы вычилить значение которое вы ожидаете.
beginner.AboutAssertions.assertEqualsWithBetterFailureMessage=Однако существуют более специфичные assert, для проверки равенства, которые дают более понятно сообщение об ошибке. (Сравните с сообщением об ошибке из предыдущего коана)
beginner.AboutAssertions.assertEqualsWithDescriptiveMessage=Вы можете добавить собственное сообщение в метод assertXXX() для предоставления дополнительной информации.
beginner.AboutAssertions.assertSameInstance=Один объект может быть равен другому объекту, но он никогда не будет таким же, как другой объект.
beginner.AboutAssertions.assertNotSameInstance=Тут мы видим, что две ссылки на один объект не тоже самое, что две ссылки на два равных объекта.

beginner.AboutObjects.objectEqualsNull=Объект класса Object никогда не будет равен null. Это справедливо для всех подклассов (все, кроме примитивных типов, является подклассом Object).
beginner.AboutObjects.objectEqualsSelf=Объект класса Object всега равен саму себе. Это справедливо для всех подклассов.
beginner.AboutObjects.objectIdentityEqualityIsTrueWhenReferringToSameObject=Объект всегда равен самому себе, даже если он хранится в разных переменных.
beginner.AboutObjects.subclassesEqualsMethodIsLooserThanDoubleEquals=Integer, and many other classes implement equals logically, in other words, they compare properties of each other and not just identity.
beginner.AboutObjects.doubleEqualsOperatorEvaluatesToTrueOnlyWithSameInstance=Double equals operator (==) does not invoke equal, it will evaluate to true if both references refer to the same object or primitive.
beginner.AboutObjects.doubleEqualsOperatorEvaluatesToFalseWithDifferentInstances=The inverse of the prior koan, though two objects may be logically equal, they are not referencing the same object.
beginner.AboutObjects.objectToString=It's easy to identify an object's state at a glance - with a good toString() implementation. Should be overridden in any objects with internal state. Default to string is classname of the instance followed by its hashCode in base 16 (hexadecimal).
beginner.AboutObjects.toStringConcatenates=Java 's string concatenation syntax utilizes addition operator to splice a string with virtually anything.
beginner.AboutObjects.toStringIsTestedForNullWhenInvokedImplicitly=String concatenation implicitly invokes toString on Objects, unless they are null. Notice no NullPointerException is thrown.

beginner.AboutInheritance.overriddenMethodsMayReturnSubtype=An overridden method may return a subtype of the return type for the method being overridden. Look at the javadoc for java.util.Collection or java.util.List - it will reveal how to eliminate this type cast.

beginner.AboutArrays.arraysDoNotConsiderElementsWhenEvaluatingEquality=Arrays utilize reference equality, they do not consider elements when determining equality.
beginner.AboutArrays.cloneEqualityIsNotRespected=The general contract of clone is that: Object a == new Object(); a != a.clone(); a.equals(a.clone()). Array instances DO NOT honor this contract, despite implementing Cloneable.
beginner.AboutArrays.anArraysHashCodeMethodDoesNotConsiderElements=Likewise with hashcode, an array instance's hashCode is that of the array, it does not incorporate elements.
beginner.AboutArrays.arraysHelperClassEqualsMethodConsidersElementsWhenDeterminingEquality=The Arrays.equals(...) method DOES evaluate elements when determining equality. This is called 'Logical Equality'.
beginner.AboutArrays.arraysHelperClassHashCodeMethodConsidersElementsWhenDeterminingHashCode=Likewise with hashCode, the Arrays.hashCode(...) method DOES consider elements when determining hashCode.
beginner.AboutArrays.arraysAreMutable=Arrays are always mutable, even when declared final. The final declaration prevents reassignment, but does nothing for elements.
beginner.AboutArrays.arraysAreIndexedAtZero=Arrays contain elements which are indexed by a number starting with zero.
beginner.AboutArrays.arrayIndexOutOfBounds=Array instances blow up when referencing an index that doesn't exist.
beginner.AboutArrays.arrayLengthCanBeChecked=It is often necessary to check the length of an array to ensure an index is valid. This is easy with the array's length property.

intermediate.AboutAutoboxing.addPrimitivesToCollection=Before Java 5, we had to convert primitives to add to collections.
intermediate.AboutAutoboxing.addPrimitivesToCollectionWithAutoBoxing=With AutoBoxing, we can rely on the compiler to perform the conversion of a primitive to its corresponding wrapper type automatically.
intermediate.AboutAutoboxing.migrateYourExistingCodeToAutoBoxingWithoutFear=With AutoBoxing, we can intermix as well
intermediate.AboutAutoboxing.allPrimitivesCanBeAutoboxed=All primitives can be autoboxed

advanced.AboutMocks.simpleAnonymousMock=How can this pass without touching the ClassUnderTest?

####################################################################
# Koans libraries properties
####################################################################
__=REPLACE ME
all_koans_succeeded=Way to go! You've completed all of the koans! Feel like writing any?
expected=expected
may_offer_clue=may offer a clue as to how you may progress, now make haste!
investigate=Ponder what's going wrong in the
level=Level
line=Line
passing_suites=Passing Suites
progress=Progress
remaining_suites=Remaining Suites
what_went_wrong=What went wrong

#only visible if enable_encouragement is true in config.properties
encouragement=Keep going, you will persevere!

koan=koan
koans=koans
out_of=out of
you_have_conquered=You have conquered

ArgumentType.duplicated_arg_error_part1=command line arg: 
ArgumentType.duplicated_arg_error_part2=\ is duplicated.

Backup.description=Backup all the koans in the src/ for easy restoration later (useful for developing koans).
Backup.args= -backup, backup, b
Backup.error=An issue was encountered saving a backup copy. Check that the directory exists and try again.
Backup.success=Koans were backed up successfully

ClassArg.args= -class, class, c
ClassArg.description=Switch is optional, app tries to find a class definition for any unrecognized string - which becomes a method argument if class is not found. If class lookup succeeds - an instance of the class will become the only koansuite to run. Permits users/developers to focus on one suite at a time.
ClassArg.error=
ClassArg.success=

Debug.args= -debug, debug, d
Debug.description=Enable debug state in the app.
Debug.error=
Debug.success=

Help.args= -help, help, h, ?
Help.description=Help. Displays stuff to, er, help you.
Help.error=
Help.success=

MethodArg.args= -method, method, m
MethodArg.description=Switch is optional, results from failing to find a class definition by an unrecognized string if switch is omitted.
MethodArg.error=
MethodArg.success=

Reset.args= -reset, reset, r, restore, -restore
Reset.description=Restore all the koans in the src/ folder to their original (or last backed up) state.
Reset.error=There was an unanticipated error encountered restoring the koan files. You're best bet is to start with a fresh copy from your downloads.
Reset.success=Koans restored successfully

RunKoans.args=
RunKoans.description=Default target. No switch - this runs if no switch is defined, or if a valid class is found as an argument.
RunKoans.error=
RunKoans.success=
